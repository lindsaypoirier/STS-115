---
title: "Lab 5 - Data Variation and Co-Variation"
output: 
  github_document:
    toc: true
    toc_depth: 2
editor_options: 
  chunk_output_type: inline
---

## Instructions and Overview

In this assignment, we will practice graphically representing variation and covariation in a dataset. To begin you will need to import and clean your dataset. You may reference last week's lab to help with this. After this, you should follow the prompts and complete the short answer questions. At various points in this assignment, you will be asked to draw insights about your dataset after calling certain functions. When I ask you to draw an insight, I’m not asking you to describe what the function does or to state the results that you get. Instead I’m asking you to interpret those results and consider what this might tell us about the issues represented in the dataset or if it might signal issues of data quality. For instance, stating “the maximum value in the age column is 999,” is not an insight. Instead you should say, “the maximum value in the age column is 999, which is much higher than I would expect and may signal that the data was input wrong or that the data collectors at using 999 to represent null values.”

## Getting Started

### Load the relevant libraries
```{r}
library(tidyverse)
library(lubridate)
library(shiny)
library(shinydashboard)
library(gapminder)
```

### Import and clean example datasets 
```{r}
hospitals <- read.csv("https://raw.githubusercontent.com/lindsaypoirier/STS-115/master/datasets/Hospitals.csv", stringsAsFactors = FALSE)

cases <- read.csv("https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_time_series/time_series_covid19_confirmed_global.csv", stringsAsFactors = FALSE)

#Do not worry about this line of code for now. Since the cases data gets appended every day with a new column representing that day's case counts, if we want the total cases per country, we need to add up all of the previous day's counts into a new column. The column below does this for us. 
cases <- 
  cases %>% 
  mutate(Total.Cases = 
           cases %>% 
           select(starts_with("X")) %>% 
           rowSums()
         ) %>%
  select(Province.State, Country.Region, Total.Cases)

hospitals$ZIP <- as.character(hospitals$ZIP)

hospitals$ZIP <- str_pad(hospitals$ZIP, 5, pad = "0") 

is.na(hospitals) <- hospitals == "NOT AVAILABLE"
is.na(hospitals) <- hospitals == -999
is.na(cases) <- cases == ""

hospitals$SOURCEDATE <- ymd_hms(hospitals$SOURCEDATE)
hospitals$VAL_DATE <- ymd_hms(hospitals$VAL_DATE)

```


### Import and clean your dataset. 
```{r}
#Copy and paste relevant code from Lab 4 to import your data here. 

#Copy and paste relevant code from Lab 4 to clean your data here. This includes any row binding, character removals, converions in variable type, date formatting, or NA conversions. 
```

## Exploring Subsetted or Grouped Data

Last week, we explored how your data was defined, how it was categorized, and how missing values were represented. Through this exercise, we were able to develop a good general overview of the observations, variables, and values in our datasets. Sometimes, however, we want to be able to zoom in to specific areas of our dataset and explore what is going on in that area. We also sometimes want to be able to zoom out - summarizing something across groups of observations in our data.  As we prepare to visualize variation and co-variation in the dataset, let's first go over how we can both zoom in and zoom out on our datasets. 

### Zooming out - aka grouping common values and summarizing

At times, we are seeking to get a broader picture of what's going on in our dataset than provided - grouping observations that share a common value and then performing a calculation to summarize something within each of those groups. For instance, I may want to know the total number of hospital beds per state. To calculate this, I would need to group all of the hospital observations by state and then sum the total number of beds in each group. 

In such cases, we can call **group_by()** to aggregate the observations with common variable values into groups. Then we will call **summarize()** to perform a calculation within each of those groups. **summarize()** takes a set of values and a calculation method and returns a single value. For instance, if we call summarize() with a numeric column in our dataset and "mean" as a calculation method, it will return the average of all the numeric values in that column. When called in conjunction with group_by(), it takes a set of values for each group and a calculation method and returns a single value for each group. 

For the hospitals dataset, we will group the observations by STATE and then use summarize to calculate the sum of BEDS per state. 

```{r}
#df %>% group_by(CATEGORICAL_VARIABLE) %>% summarize(NEW_VARIABLE_NAME = sum(NUMBERIC_VARIABLE, na.rm = TRUE)) %>% ungroup()
hospitals %>% group_by(STATE) %>% summarize(state_beds = sum(BEDS, na.rm = TRUE)) %>% ungroup()
```

> Notice that I close each of these calls with **ungroup()**. When we group_by() a variable, any subsequent function calls will continue to be performed on the grouped data, unless we ungroup() it. This can be important if we want to filter to specific values after we summarize() the data. Assuming that we don't want to perform a filter operation within each group but on the entire new dataframe created after summarizing, we need to ungroup() the data before performing the filter() operation. 

For some of you, you will be using group_by() and summarize() often in all future labs. It is quite useful when you need to generalize your data before statistically analyzing it so that we can ensure that the values we are statistically analyzing are all being reported across the same timeframes and at the same scale. 

In the hospitals dataset, this is less of a concern because as we learned last week, the observational unit of the dataset is one thing without qualifiers - a hospital. The BEDS variable is always going to refer to the number of BEDS at a hospital.

Each observation in the cases dataset, on the other hand, refers to a combination of things - a province and a country - and not every country is reporting data at the province level. This means that sometimes the Total.Cases variable is referring to the number of cases in a country and sometimes it is referring to the number of cases in a Province. If we wanted to statistically analyze the number of cases across observations, we first need to transform the dataset so that each observation is reported at the same scale. In other words, we need to standardize the observational unit across the dataset. This will be at the country level, since we do not always have data at the province level. To do that, we will need to group_by() Country.Region and then summarize the sum of Total.Cases.

```{r}
cases %>%
  group_by(Country.Region) %>%
  summarize(Total.Cases = sum(Total.Cases, na.rm = TRUE)) %>%
  ungroup()
```

Once we've done this, we can confidently statistically analyze the Total.Cases variable because we know that the number is always referring to the number of cases in a country.

Let's test the extent to which you will need to group_by() and summarize() to statistically analyze numeric values your data. Select a discrete numeric variable in your dataset. Now complete the statement below:

```{r}
#Uncomment the last line below and fill in the blanks for your dataset. 
#paste(df$DISCRETE_VARIABLE[1], "refers to a number of [FILL DISCRETE VARIABLE] in a _____ in my dataset.)

#Example:
paste(hospitals$BEDS[1], "refers to a number of beds in a hospital in my dataset.")
paste(cases$Total.Cases[1], "refers to a number of cases in a country and/or province in my dataset.")

#paste(_____$_____[1], "refers to a number of _____ in a _____ in my dataset.)
```
How did you fill in the last _____? 
Is your observational unit one thing or phenomenon without qualifiers (e.g. one hospital, or one country)? If this is the case, group_by() and summarize() won't be as essential when statistically analyzing your dataset. **If so, we will say that you do not have qualified units of observation.**

OR is your observational unit one thing or phenomenon with additional qualifiers (e.g. one chemical reported at a particular facility or one census tract reporting in a particular year)? If this is the case, group_by() and summarize() will be essential when statistically analyzing your dataset. **If so, we will say that you do have qualified units of observation.**

Are your units of observation qualified? If they are, what will you need to group_by() (a year?, a geography?) and summarize() (the sum of total cases, the average of a measurement?) to standardize how the numeric values in your dataset are reported across all observations? Note: If you are struggling with this, please reach out to me.
```{r eval=FALSE}
My units of observation are _____.  

I will need to group by _____ and summarize by calculating the _____ of _____ to standardize how the numeric values in my dataset are reported across all observations. 
```

Select a categorical variable that you would like to group your data by, so that you can summarize some statistics across each grouping. You may group your data by a particular year, by a particular location (such as a state or a region), or by a particular category. Then select a numeric variable in your dataset to summarize by. For instance, you may want to sum the total number of reports in a given year, or find the average number of cases reported in a certain state. 

```{r}
#Uncomment the appropriate lines below, and fill in your data frame, variables, and summarize variable name, and math function. 
#_____ %>% group_by(_____) %>% summarize(_____ = _____(_____, na.rm = TRUE)) %>% ungroup()
```

What insight can you draw from grouping and summarizing?

```{r eval=FALSE}
Fill your response here. 
```

### Zooming in - Exploring Filtered Categorical Data

#### Filtering to a Category

Filtering is one way we can zoom in on our data - exploring only those observations that meet a particular criteria.

For instance, last week we learned above that one criteria for being designated as a Critical Access Hospital is that the hospital must have 25 or fewer inpatient beds. We may want to see how the values for BEDS change when we filter to (or zoom into) just those observations representing critical access hospitals. Below I will do this, select the BEDS variable, and call summary().

```{r}
#df %>% filter(CATEGORICAL_VARIABLE == "VALUE") %>% select(NUMERIC_VARIABLE) %>% summary() 
hospitals %>% filter(TYPE == "CRITICAL ACCESS") %>% select(BEDS) %>% summary()
```

We can see that there are some hospitals in the US that have been designated as critical access hospitals that have more than 25 beds. Since this does not align with the criteria for critical access hospitals that we discovered in our research, it is likely something that we will want to investigate further.

##### What if I have qualified units of observation?

If this is the case, be sure to filter to a value that qualifies your observations. For instance, if your observational unit is a county reporting in a particular year, filter to one year. Otherwise, when you gather summary statistics for a numeric variable, you may be summarizing across numbers reported at different times or geographic scales. If I were to call summary() on the Total.Cases variable in the cases dataset, I would be gathering statistics across numbers reported at different geographic scales. Below, I filter the cases dataset to one Country - Canada - so that I'm gathering statistics across all provinces in Canada. 

```{r}
cases %>% 
  filter(Country.Region == "Canada") %>%
  select(Total.Cases) %>%
  summary()
```


```{r}
gapminder %>% 
  filter(year == 2007) %>%
  select(pop) %>%
  summary()
```

For your own dataset, select one of the values that you identified from calling distinct() on a categorical variable in last week's lab. Filter the dataset to the rows representing that value, select a numeric variable to explore, and then call summary(). If you have qualified units of observation, be sure to filter to a value that _____.  

```{r}
#Uncomment the appropriate lines below, and fill in your data frame, variables, and value. 
#_____ %>% filter(_____ == "_____") %>% select(_____) %>% summary()

```

What insight can you draw from calling summary() on your own filtered dataset?

```{r eval=FALSE}
Fill your response here. 
```

### Zooming in - aka exploring filtered numeric data

We may also want to see which states have hospitals with more than 1500 beds. To do so, we would filter the data to those observations where BEDS is greater than 1500, and then we would check the distinct() STATES remaining in the data.

```{r}
#df %>% filter(NUMBERIC_VARIABLE > VALUE) %>% distinct(CATEGORICAL_VARIABLE)
hospitals %>% filter(BEDS > 1500) %>% distinct(STATE)
```
From this exercise, we can see that only two states have hospitals with more than 1500 beds available. 

##### What if I have qualified units of observation?

If this is the case, you will need to group_by(), summarize(), and ungroup() before calling this function. Otherwise, when you filter to rows greater than or less than a numeric variable, you may be filtering across numbers reported at different times or geographic scales. For example, in the cases dataset, we will summarize the total cases per country and then check the distinct countries reporting more than 100,000 cases.

```{r}
cases %>% 
  group_by(Country.Region) %>%
  summarize(Total.Cases = sum(Total.Cases, na.rm = FALSE)) %>%
  ungroup() %>%
  filter(Total.Cases > 100000) %>% 
  distinct(Country.Region)
```

Select a numeric variable in your dataset that represents the extent or scale of the issue you are studying. Pick a number that you believe serves as a good indicator that this issue is at a notable extent or scale, and filter the dataset to all the rows greater than (or less than) this number. Check the remaining distinct values in a categorical variable in the dataset. If necessary, group_by(), summarize(), and ungroup() your observations first. 

```{r}
#Uncomment the appropriate lines below, and fill in your data frame, variables, condition, and value. 
#_____ %>% filter(_____ _____ _____) %>% distinct(_____)

#If qualified:
#_____ %>% group_by(_____) %>% summarize(_____ = _____(_____, na.rm = TRUE)) %>% ungroup() %>% filter(_____ _____ _____) %>% distinct(_____)

```

What insight can you draw from calling distinct on the filtered data?

```{r eval=FALSE}
Fill your response here. 
```

Combine any combination of the 4 verbs we learned in class this week or last (select, filter, group by, or summarize) to explore your dataset further. You may also use arrange, summary, or distinct. 

```{r}
#Fill your function here. 
```

What insight can you draw from running this function?

```{r eval=FALSE}
Fill your response here. 
```

Combine any combination of the 4 verbs we learned in class this week or last (select, filter, group by, or summarize) to explore your dataset further. You may also use arrange, summary, or distinct. 

```{r}
#Fill your function here. 
```

What insight can you draw from running this function?

```{r eval=FALSE}
Fill your response here. 
```

Combine any combination of the 4 verbs we learned in class this week or last (select, filter, group_by, or summarize) to explore your dataset further. You may also use arrange, summary, or distinct. 

```{r}
#Fill your function here. 
```

What insight can you draw from running this function?

```{r eval=FALSE}
Fill your response here. 
```

## Variation

Variation is the extent to which the values that constitute a particular variable vary from observation to observation. Do we have a whole bunch of one particular value in a variable, and very few of another? Or maybe, do we have a more even distribution of values across a variable?

### ggplot

At this point in the assignment, we will begin leveraging the Tidyverse package **ggplot** to create plots for visualizing the data. To create a plot with ggplot, we will follow this basic formula:

```{r eval=FALSE}
df %>% 
  ggplot(aes(x = VARIABLE_NAME)) + 
  CHART_TYPE
```

For example, for a bar chart, you will call:

```{r eval=FALSE}
df %>% 
  ggplot(aes(x = VARIABLE_NAME)) + 
  geom_bar()
```

For a column chart, you will call:

```{r eval=FALSE}
df %>% 
  ggplot(aes(x = VARIABLE_NAME, y = VARIABLE_NAME)) + 
  geom_col()
```
  
Let's break that down a bit. First, as you have been doing with the **dplyr** package, you will call your dataframe. Following your dataframe and a pipe, you will call ggplot(), which basically tells R to prepare to create a plot. Inside ggplot, you will list *aesthetics*. These are variables in the dataset that you would like to appear on your plot. Setting x = VARIABLE_NAME tells ggplot() what variable to plot on the x-axis. Setting y = = VARIABLE_NAME tells ggplot() what variable to plot on the y-axis. Finally, following a plus (+) sign, you tell ggplot which type of plot to create. The [ggplot cheatsheet](https://rstudio.com/wp-content/uploads/2015/03/ggplot2-cheatsheet.pdf) lists a number of plots that you can create with ggplot, as well as a number of different ways to style the plot. We will practice several of these below. 

For every plot that you produce, I will expect you to add a title and labels to the x and y axis. You can do this as follows:

```{r eval=FALSE}
df %>% 
  ggplot(aes(x = VARIABLE_NAME, y = VARIABLE_NAME)) + 
  geom_col() +
  labs(title = "FILL TITLE", x = "FILL X-AXIS LABEL", y = "FILL Y-AXIS LABEL)
```

There are also a number of useful tools for styling your plots. For instance we can set the theme of the plot to look a bit more polished by adding "+ theme_bw()" to the plot. 

```{r eval=FALSE}
df %>% 
  ggplot(aes(x = VARIABLE_NAME, y = VARIABLE_NAME)) + 
  geom_col() +
  labs(title = "FILL TITLE", x = "FILL X-AXIS LABEL", y = "FILL Y-AXIS LABEL") +
  theme_bw()
```

Two styling issues that I'm sure will come up in most of your plots include:
* changing x or y axis tick numbers from scientific to comma notation: + scale_x_continuous(labels = scales::comma) OR + scale_y_continuous(labels = scales::comma)
* turning x axis tick marks 90 degrees so that they do not overlap: + theme(axis.text.x = element_text(angle = 90, hjust=1)) OR + theme(axis.text.y = element_text(angle = 90, hjust=1))

```{r eval=FALSE}
df %>% 
  ggplot(aes(x = VARIABLE_NAME, y = VARIABLE_NAME)) + 
  geom_col() +
  labs(title = "FILL TITLE", x = "FILL X-AXIS LABEL", y = "FILL Y-AXIS LABEL") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90, hjust=1)) + #Turn labels 90 degrees
  scale_x_continuous(labels = scales::comma) #Change labels from scientific to comma notation
```

So how do we visualize variation with ggplot? Below I describe two different plots that you can leverage to visualize variation - a bar plot and a frequency plot. 

### Bar Plot

A *bar plot* displays the number of times each value appears in a categorial variable. This will tell us how the observations in the dataset *vary* in regards to that variable. In other words, this plot will communicate the number of observations in your dataset by that variable. 

```{r fig.height=5, fig.width=10}
#df %>% ggplot(aes(x = CATEGORICAL_VARIABLE)) + geom_bar() + labs(title = "TITLE", x = "X-AXIS NAME", y = "Y-AXIS NAME")

hospitals %>% 
  ggplot(aes(x = TYPE)) + 
  geom_bar() +
  labs(title = "Number of Hospitals in the US by Type", x = "Type", y = "Count of Hospitals") + #Adds a title to the plot
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90, hjust=1)) #Changes x-axis tick labels 90 degrees 
```

#### Titling a Bar Plot

Note how I titled my plot above: "Number of Hospitals in the US by Type" Remember last week, when we identified what makes each observation in our dataset unique? This is one of the cases where that becomes particularly important. Here I am counting the observations by Type, and in order to know what I'm counting, I need to know what each observation refers to. A good formula for titling bar plots is as follows:

Number of _____ by [x-axis variable name]

In order to fill in the blank line above, consider the statement we produced last week: "I have nrow(df) unique _____ represented in my dataset." That blank line told us what each observation in the dataset represented. However we filled in that blank line should also be how we fill in the title of a bar plot. 

The [x-axis variable name] should be your x-label and "Count of ______" (filled the same as above) should be your y-label.

##### What if I have qualified units of observation?

If this is the case, then your y-axis is not counting a single thing like the number of hospitals, but a combination of things like the number of province/country pairs. 
For instance, let's say your data reports the population of each country each year. This is the case with a dataset called gapminder (a dataset of populations across countries and years often used for R teaching purposes). Check out this dataset below:

```{r}
gapminder %>% head(6)
```

Now let's say that you wanted to plot the number of countries per continent. If you were to call:
```{r}
gapminder %>% 
  ggplot(aes(x = continent)) + 
  geom_bar() +
  labs(title = "Number of Countries per Continent", x = "Continent", y = "Count of Countries") + #Adds a title to the plot
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90, hjust=1)) #Changes x-axis tick labels 90 degrees 
```

... you would be counting the combination of the number of countries and years per continent. Each country would be represented in the bar for every year that it was included in the dataset. In other words, the y-axis would not just represent countries but both countries and years. If we want the y-axis to only be counting one thing, then we need to first reduce the dataset to the distinct values of what you wish to count and what you wish to count by. You can do this by placing the distinct call before calling ggplot. 

```{r}
gapminder %>% 
  distinct(country, continent) %>%
  ggplot(aes(x = continent)) + 
  geom_bar() +
  labs(title = "Number of Countries per Continent", x = "Continent", y = "Count of Countries") + #Adds a title to the plot
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90, hjust=1)) #Changes x-axis tick labels 90 degrees
```


### Frequency Plot

A *frequency plot* will display the distribution of values in a numeric variable within a designated set of increments. This will tell us how the observations in the dataset *vary* in regards to that variable. In other words, this plot will communicate the number of observations in your dataset broken down into increments of that variable. 

```{r fig.height=5, fig.width=10}
#df %>% ggplot(aes(x = NUMERIC_VARIABLE)) + geom_freqpoly(binwidth = 1) + labs(title = "TITLE", x = "X-AXIS NAME", y = "Y-AXIS NAME")

hospitals %>% 
  ggplot(aes(x = BEDS)) +
  geom_freqpoly(binwidth = 10) +
  labs(title = "Distribution of Beds across Hospitals in the US", x = "Beds", y = "Count of Hospitals") +
  theme_bw()
```

> Note that binwidth refers to the size of the increments at which frequency will be calculated. Above the binwidth is set to 10. This means that ggplot will display the frequency of each value at intervals of 10, 20, 30, 40, etc. When we set the bindwidth to 1, ggplot will display the frequency of each value at intervals of 1, 2, 3, 4. etc. What difference does this make? 

Notice what happens when we set the binwidth to 1. While above we count the number of hospitals with 0-10 beds , 10-20 beds, 20-30 beds, etc, this will count the number of hospitals with 0-1 beds, 1-2 beds, 2-3 beds, and so on. Because we are counting the number in such small increments, the plot will look much more jagged and will take a longer time to load. This plot displays the counts in *finer* granularity than the first plot. 
```{r fig.height=5, fig.width=10}
hospitals %>% 
  ggplot(aes(x = BEDS)) +
  geom_freqpoly(binwidth = 1) +
  labs(title = "Distribution of Beds across Hospitals in the US", x = "Beds", y = "Count of Hospitals") + 
  theme_bw()
```

When we set the binwidth to 100, we count the number of hospitals with 0-100 beds, 100-200 beds, 200-300 beds, and so on. Because we are counting the number in larger increments, the plot will look much smoother and will take less time to load. This plot displays the counts in *thicker* granularity than the first plot.
```{r fig.height=5, fig.width=10}
hospitals %>% 
  ggplot(aes(x = BEDS)) +
  geom_freqpoly(binwidth = 100) +
  labs(title = "Distribution of Beds across Hospitals in the US", x = "Beds", y = "Count of Hospitals") +
  theme_bw()
```
#### Titling a Frequency Plot

Note how I titled my plot above: "Distribution of Beds across Hospitals in the US" Consider again what makes each observation unique. Here I am counting the observations by number of Beds, and in order to know what I'm counting, I need to know what each observation refers to. A good formula for titling frequency plots is as follows:

Frequency of [x-axis variable name] across _____ 

We can fill in the blank in the same way we did above. Consider the statement we produced last week: "I have nrow(df) unique _____ represented in my dataset." However we filled in that blank line should also be how we fill in the title of a frequency plot. 

The [x-axis variable name] should be your x-label and "Count of ______" (filled the same as above) should be your y-label.

### What if I have qualified units of observation?

Let's talk about what would happen if I were to make a frequency plot of the Total.Cases in the cases dataset:
```{r fig.height=5, fig.width=10}
cases %>% 
  ggplot(aes(x = Total.Cases)) + 
  geom_freqpoly(binwidth = 10000) +
  labs(title = "Distribution of Cases across ____", x = "Total Cases", y = "Count of _____") + # To add titles and labels
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90, hjust=1)) + #Turn labels 90 degrees
  scale_x_continuous(labels = scales::comma) #Change labels from scientific to comma notation
```
We know that each observation in the cases dataset refers to a province/country pair. So here I'm counting the number of province/countries in each bracket of total cases. Since only some countries in this dataset are broken into provinces, we are comparing counts of cases across different geographic scales - sometimes at the province level and sometimes at the country level. In this case, it makes more sense to total up the number of cases per country (that is across all provinces, if the totals have been split up that way) and then plot the distribution of cases across countries. We can use group_by() and summarize() to do this:

```{r fig.height=5, fig.width=10}
cases %>% 
  group_by(Country.Region) %>%
  summarize(Total.Cases = sum(Total.Cases, na.rm = TRUE)) %>%
  ungroup() %>%
  ggplot(aes(x = Total.Cases)) + 
  geom_freqpoly(binwidth = 10000) +
  labs(title = "Distribution of Cases across Countries", x = "Total Cases", y = "Count of Countries") + # To add titles and labels
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90, hjust=1)) + #Turn labels 90 degrees
  scale_x_continuous(labels = scales::comma) #Change labels from scientific to comma notation
```
Now let's say that we had different totals being reported for each day for each country in this datset. In order to plot the distribution of total cases across countries, again we would want to calculate the overall case totals for each country - grouping by country and summing the daily totals to get an overall total before plotting. Otherwise we would be plotting "Distribution of Cases across Countries per Day."

Without grouping and summarizing this data, your plot will represent multiple counts of the same issue or geography at different points in time. This may be your goal - "Distribution of Cases across Countries per Day" - is certainly an interesting plot. However, if it is not your goal, you will want to group_by() and summarize() your data first. 

### Select a categorical variable for which you want to visualize the frequency of times it appears in the dataset. 

I recommend that you select one of the same categorical variables that you analyzed with the distinct() function last week. At this point hold off on selecting a geographic categorical variable, such as Country, State, or County. If you have qualified units of observation, be sure to reduce your dataset to the distinct values you wish to count. 

```{r fig.height=5, fig.width=10}
#Uncomment the line below and fill appropriately. Add a title and labels to your plots, and adjust its style to be legible.
#_____ %>% ggplot(aes(x = _____)) + geom_bar()

#If qualified:
#_____ %>% distinct(_____) %>% ggplot(aes(x = _____)) + geom_bar()
```

Reflect on the distribution of categories in the dataset. Is there an even distribution of observations across each category, or are certain categories more represented than others? Why might this be? What does this say about the social, political, or economic landscape of your topic? 

```{r eval=FALSE}
Fill response here. 
```

Reflect on what you learned about the history of the categories you plotted above in last week's lab. How have the social, political, and economic forces shaping this categorization impacted how we count observations related to this topic? How might this plot look different if this variable had been categorized in a different way?

```{r eval=FALSE}
Fill response here. 
```

### Select a numeric variable for which you want to visualize the distribution of a set of values. 

If needed, group_by() and summarize() values to ensure that all of the observations you are counting are at the same scale. 

```{r fig.height=5, fig.width=10}
#Uncomment the line below and fill appropriately. Add a title and labels to your plots.
#_____ %>% ggplot(aes(x = _____)) + geom_freqpoly(binwidth = _____) 

#If qualified:
#_____ %>% group_by(_____) %>% summarize(_____ = _____(_____, na.rm = TRUE)) %>% ungroup() %>% ggplot(aes(x = _____)) + geom_freqpoly(binwidth = _____)
```

This gives us information about the distribution of values in the dataset. Reflect on the distribution of values. What are the range of values represented in the data? Are the values evenly distributed, or are certain values more represented than others? Why might this be? Do any of the values surprise you? Why? 

```{r eval=FALSE}
Fill response here. 
```

Why did you select the binwidth that you did? How might the story your plot tells change if you were to change the binwidth? What anomalies might be hidden with a larger binwidth, and what trends might be hidden with a smaller binwidth?

```{r eval=FALSE}
Fill response here. 
```

Check how the numeric variable was defined in the data dictionary, and quote the defintion below. How might the counts represented in your frequency plot appear differently if this variable was defined differently?

```{r eval=FALSE}
Fill response here. 
```

### Produce two more plots that display variation. Continue to hold off on selecting a geographic categorical variable. 

```{r fig.height=5, fig.width=10}
#Fill the code for plot 1 here. Add a title and labels to your plots.
```

What insight can you draw from this plot?

```{r eval=FALSE}
Fill your response here. 
```

```{r fig.height=5, fig.width=10}
#Fill the code for plot 2 here. Add a title and labels to your plots.
```

What insight can you draw from this plot?

```{r eval=FALSE}
Fill your response here. 
```

## Co-variation

Co-variation is the extent to which the values that constitute two or more variables vary in relation to one another. To visualize co-variation, we might create:

### Count Plots

*Count plots* display how many times two categorical values appear together in a dataset. 

```{r fig.height=5, fig.width=10}
#df %>% ggplot(aes(x = CATEGORICAL_VARIABLE, y = CATEGORICAL_VARIABLE)) + geom_count()

hospitals %>% 
  ggplot(aes(x = TYPE, y = OWNER)) + 
  geom_count() +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust=1))
```


```{r}
gapminder %>% 
  ggplot(aes(x = continent, y = as.factor(year))) + 
  geom_count() +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust=1))
```

### Stacked Frequency Plots 

*Stacked frequency plots* display the distribution of numeric values in a variable, grouped by a categorical value.

```{r fig.height=5, fig.width=10}
#df %>% ggplot(aes(x = NUMERIC_VARIABLE, col = CATEGORICAL_VARIABLE)) + geom_freqpoly(binwidth = 1)

hospitals %>% 
  ggplot(aes(x = BEDS, col = TYPE)) + 
  geom_freqpoly(binwidth = 100) +
  theme_bw()

```

```{r fig.height=5, fig.width=10}
#df %>% ggplot(aes(x = NUMERIC_VARIABLE, col = CATEGORICAL_VARIABLE)) + geom_freqpoly(binwidth = 1)

gapminder %>% 
  ggplot(aes(x = pop, col = as.factor(year))) + 
  geom_freqpoly(binwidth = 100000000) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust=1))
```


### Point plots

*Point plots* display the relationship between a categorical variable and a numeric variable.

```{r fig.height=5, fig.width=10}
#df %>% ggplot(aes(x = CATEGORICAL_VARIABLE, y = NUMERIC_VARIABLE)) + geom_point()

hospitals %>% 
  ggplot(aes(x = TYPE, y = BEDS)) + 
  geom_point() +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust=1))

# Note that the plot above exhibits overplotting - when the data represented on a plot overlaps, making it difficult to discern one point from the next. There are various tools available to deal with over-plotting. You can reduce the size of points on the plot, increase their transparency, or set them to slightly offset each other (known as adding jitter). We do all three below.

hospitals %>% 
  ggplot(aes(x = TYPE, y = BEDS)) + 
  geom_jitter(size = 0.5, alpha = 0.1) + #Change geom_point to geom_jitter, reduce the size, add transparency for overplotting
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust=1))

# Also note that sometimes, when we add more aesthetics to the plot, we can run into other issues with overplotting. For instance, when set set the color of the point to represent the owner, it can be difficult to discern points when we've set them to a degree of transparency. Here we can change the shape of the point to an outline. 
hospitals %>% 
  ggplot(aes(x = TYPE, y = BEDS, col = OWNER)) + 
  geom_jitter(size = 1, alpha = 0.8, shape = 21) + #Shape 21 is an outline of a point. 
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust=1))
```

```{r fig.height=5, fig.width=10}
gapminder %>% 
  ggplot(aes(x = continent, y = pop, col = as.factor(year))) + 
  geom_jitter(size = 1, alpha = 0.8, shape = 21) + #Shape 21 is an outline of a point. 
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust=1))
```


### Scatterplots

*Scatterplots* display the relationship or correlation between two numeric variables.

```{r fig.height=8, fig.width=10}
#ggplot(df, aes(NUMERIC_VARIABLE, NUMERIC_VARIABLE)) + geom_point()

hospitals %>% 
  ggplot(aes(x = BEDS, y = POPULATION)) + 
  geom_point(size = 0.5) +
  theme_bw()
```

```{r fig.height=8, fig.width=10}
#ggplot(df, aes(NUMERIC_VARIABLE, NUMERIC_VARIABLE)) + geom_point()

gapminder %>% 
  ggplot(aes(x = gdpPercap, y = lifeExp, col = as.factor(year))) + 
  geom_point(size = 0.5) +
  theme_bw()
```

> Note how this plot is particularly useful for finding outliers.

### Produce four plots that represent co-variation in your dataset. 

You need not include every plot I described above. At this point, please continue to hold off on selecting a geographic categorical variable. If needed, group_by() and summarize() values to ensure that all of the observations you are counting are at the same scale. 

```{r fig.height=8, fig.width=10}
#Fill the code for plot 1 here. Add a title and labels to your plots. Be sure to adjust for overplotting.
```

What insight can you draw from this plot?

```{r eval=FALSE}
Fill your response here. 
```

```{r fig.height=8, fig.width=10}
#Fill the code for plot 2 here. Add a title and labels to your plots. Be sure to adjust for overplotting.
```

What insight can you draw from this plot?

```{r eval=FALSE}
Fill your response here. 
```

```{r fig.height=8, fig.width=10}
#Fill the code for plot 3 here. Add a title and labels to your plots. Be sure to adjust for overplotting.
```

What insight can you draw from this plot?

```{r eval=FALSE}
Fill your response here. 
```

```{r fig.height=8, fig.width=10}
#Fill the code for plot 4 here. Add a title and labels to your plots. Be sure to adjust for overplotting.
```

What insight can you draw from this plot?

```{r eval=FALSE}
Fill your response here. 
```

## Start a shiny app.

At this point in the quarter, we are prepared to start piecing together a dashboard for displaying the data. Shiny Apps have two components - a front end (ui), and a backend (server). On the front end, we will be coding how we want our data displayed. **For this week, the only thing you need to do on the front end is fill in your title.** On the backend, we will be coding our data analysis. 

Fill in your title in the UI. 

```{r}
ui <- dashboardPage(
  
  dashboardHeader(title = "TITLE HERE"),
  
  dashboardSidebar(
    #inputs will go here. 
  ),
  
  dashboardBody(
      box(plotOutput("plot1")),
      box(plotOutput("plot2"))
  )
)
```

Replace my plots in the code with two of the plots that you created in this lab. 
```{r}
server <- function(input, output, session) {
  
  output$plot1 <- renderPlot({
    hospitals %>% ggplot(aes(x = TYPE)) + geom_bar()
    #Replace plot above with your own plot. 
    
  })
  
  output$plot2 <- renderPlot({
    hospitals %>% ggplot(aes(x = TYPE)) + geom_bar()
    #Replace plot above with your own plot. 
  })
  
}
```

```{r}
shinyApp(ui, server)
```

When you knit this notebook, you will get a prompt asking whether you would prefer to render and run this document as Shiny. Click No. We will be leaving this notebook in a GitHub document format. 

## More Examples and Useful Functions (This is just for reference.)

### Binwidth

```{r fig.height=5, fig.width=10}
#Let's say we have a vector of ruler measurements:

ruler_measurements <- c(0.7, 1.2, 1.2, 1.4, 1.5, 1.6, 2.3, 3.6, 3.8, 3.9)
df <- data.frame(ruler_measurements)

#When we set the binwidth to 0.1, it counts the numbers of values that appear in each increment of 0.1. Since our values are already being record to the tenths, we will see a count of 1 for each value except 1.2, which appears in the vector twice.
df %>% ggplot(aes(x = ruler_measurements)) + geom_freqpoly(binwidth = 0.1)

#When we set the binwidth to 1, it counts the numbers of values that appear in each increment of 1. In this case, because we have decimals, values from -0.5 to 0.5 are included in each count. You'll notice at interval one, we see a count of 5, which includes: 0.7, 1.2, 1.2, 1.4, and 1.5. This is likely the most useful binwidth for this plot. 
df %>% ggplot(aes(x = ruler_measurements)) + geom_freqpoly(binwidth = 1) 

#When we set the binwidth to 10, it counts the numbers of values that appear in each increment of 10. Since all values are less than 10, all values are included in one count.
df %>% ggplot(aes(x = ruler_measurements)) + geom_freqpoly(binwidth = 10)

```


```{r fig.height=5, fig.width=10}
#Now let's say we have a vector of ages:

ages <- c(15, 22, 24, 27, 28, 30, 33, 40, 45, 58)
df <- data.frame(ages)

#When we set the binwidth to 0.1, it counts the numbers of values that appear in each increment of 0.1. Since our values are recorded in whole numbers, this binwidth doens't tell us much about frequency.
df %>% ggplot(aes(x = ages)) + geom_freqpoly(binwidth = 0.1)

#When we set the binwidth to 1, it counts the numbers of values that appear in each increment of 1. Since no whole numbers in the vector repeat, the frequency for each age in the vector will be 1.
df %>% ggplot(aes(x = ages)) + geom_freqpoly(binwidth = 1) 

#When we set the binwidth to 10, it counts the numbers of values that appear in each increment of 10. This allows us to count the number of people in each 10-year age bracket. This is likely the most useful binwidth for this plot. 
df %>% ggplot(aes(x = ages)) + geom_freqpoly(binwidth = 10)

```

### count

**count()** counts the number of times each value appears in a variable. In other words, this function groups observations that share a common variable value and then counts the number of observations in each group. In the hospitals dataset, if I wanted to know the number of hospitals of each TYPE in the dataset, I would count by TYPE. Below we calculate the number of hospitals per state by counting by STATE. 

```{r}
#df %>% count(CATEGORICAL_VARIABLE)
hospitals %>% count(STATE)
```

### filtering to the row with the max or min of a variable

### grouping by more than one variable
