---
title: "Lab 7 - Geographic and Temporal Context"
output: 
  github_document:
    toc: true
    toc_depth: 2
editor_options: 
  chunk_output_type: inline
---

## Instructions and Overview

At this point in the quarter, we have produced a number of plots and calculate a number of measures in regards to our data. Now, we're going to explore in more depth how the stories the data tell change depending on where we look. This exploration will turn into user inputs in our Shiny app. 

## Getting Started

### Load the relevant libraries
```{r}
library(tidyverse)
library(lubridate)
library(shiny)
library(shinydashboard)
library(shinyWidgets)
```

### Import and clean example datasets 
```{r}
hospitals <- read.csv("https://raw.githubusercontent.com/lindsaypoirier/STS-115/master/datasets/Hospitals.csv", stringsAsFactors = FALSE)

cases <- read.csv("https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_time_series/time_series_covid19_confirmed_global.csv", stringsAsFactors = FALSE)

#Do not worry about this line of code for now. Since the cases data gets appended every day with a new column representing that day's case counts, if we want the total cases per country, we need to add up all of the previous day's counts into a new column. The column below does this for us. 
cases <- 
  cases %>% 
  mutate(Total.Cases = 
           cases %>% 
           select(starts_with("X")) %>% 
           rowSums()
         ) %>%
  select(Province.State, Country.Region, Total.Cases)

hospitals$ZIP <- as.character(hospitals$ZIP)

hospitals$ZIP <- str_pad(hospitals$ZIP, 5, pad = "0") 

is.na(hospitals) <- hospitals == "NOT AVAILABLE"
is.na(hospitals) <- hospitals == -999
is.na(cases) <- cases == ""

hospitals$SOURCEDATE <- ymd_hms(hospitals$SOURCEDATE)
hospitals$VAL_DATE <- ymd_hms(hospitals$VAL_DATE)
```

### Import and clean your dataset. 
```{r}
#Copy and paste relevant code from Lab 4 to import your data here. 

#Copy and paste relevant code from Lab 4 to clean your data here. This includes any row binding, character removals, converions in variable type, date formatting, or NA conversions. 
```

## Facets

To get us started in putting our data into context, we are going to look at some of the plots we produced in previous labs grouped according to a categorical variable in our dataset. 

By *faceting* plots, we split them into a series of panels each representing the grouped data associated with a particular value in a categorical variable. Let's start with an easy example from our hospitals data - faceting a bar plot of the number of hospitals that have a helipad by state. 

```{r fig.height=5, fig.width=10}
#df %>% ggplot(aes(x = CATEGORICAL_VARIABLE)) + geom_bar() + facet_wrap(~CATEGORICAL_VARIABLE)

#without facet_wrap()
hospitals %>% 
  ggplot(aes(x = HELIPAD)) + 
  geom_bar() +
  theme_bw()

#with facet_wrap()
hospitals %>% 
  ggplot(aes(x = HELIPAD)) + 
  geom_bar() +
  facet_wrap(~STATE) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust=1, size = 6), 
        axis.text.y = element_text(size = 6),
        strip.text = element_text(size = 6)) 
  
```

The first plot suggests that more hospitals have helipads than those that don't. Grouping this by state, however, we can see that in some states (like California and New York), more hospitals don't have helipads than those that do. Faceting can help us zoom into the data for more geographic specificity. 

Let's also facet data by a temporal variable. Assuming we have already converted a date/time variable in our dataset into a data/time format (using lubridate in lab 4), we should be able to extract a year, month, day (and if available hour, minute, and second) from the data using these lubridate functions:

* year(DATE_VARIABLE) will extract the year from the date
* month(DATE_VARIABLE) will extract the month from the date
* day(DATE_VARIABLE) will extract the day from the date
* ... and so on


```{r}
#without facet_wrap()
hospitals %>% 
  ggplot(aes(x = STATUS)) + 
  geom_bar() +
  theme_bw()

#with facet_wrap()
hospitals %>% 
  ggplot(aes(x = STATUS)) + 
  geom_bar() +
  facet_wrap(~year(SOURCEDATE)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust=1, size = 6), 
        axis.text.y = element_text(size = 6),
        strip.text = element_text(size = 6)) 
```
Faceting this plot by the year in which the data was sourced helps put the STATUS field into context. We can see that the vast majority of the data represented in the plot was sourced in 2018. We know that hospitals across the country are not open or closed in perpetuity, so we need to take the temporal context of the data into consideration when presenting our results. 

Copy and paste a plot from one of your previous labs. Then copy it again and facet it by a geographic or temporal variable. 

```{r fig.height=5, fig.width=10}
#df %>% ggplot(aes(x = CATEGORICAL_VARIABLE)) + geom_bar() + facet_wrap(~CATEGORICAL_VARIABLE)

#Copy and paste a previoulsy created plot here. 

#Copy that plot again and facet it by a geographic or temporal variable. Adjust the theme as I have above to make your plot more legible.  
```

How do the stories that the two plots tell differ? What does your first plot tell you about the geo-political landscape of the issue you are studying? - OR - What does the first plot tell you about the temporal landscape of the issue you are studying?

```{r eval=FALSE}
Fill your response here. 
```

Repeat the exercise you completed above for a second plot you created in a previous lab.  

```{r fig.height=5, fig.width=10}
#df %>% ggplot(aes(x = CATEGORICAL_VARIABLE)) + geom_bar() + facet_wrap(~CATEGORICAL_VARIABLE)

#Copy and paste a previoulsy created plot here. 

#Copy that plot again and facet it by a geographic or temporal variable. Adjust the theme as I have above to make your plot more legible.  
```

How do the stories that the two plots tell differ? What does your second plot tell you about the geo-political landscape of the issue you are studying? - OR - What does the second plot tell you about the temporal landscape of the issue you are studying?

```{r eval=FALSE}
Fill your response here. 
```

Repeat the exercise you completed above for a third plot you created in a previous lab.  

```{r fig.height=5, fig.width=10}
#df %>% ggplot(aes(x = CATEGORICAL_VARIABLE)) + geom_bar() + facet_wrap(~CATEGORICAL_VARIABLE)

#Copy and paste a previoulsy created plot here. 

#Copy that plot again and facet it by a geographic or temporal variable. Adjust the theme as I have above to make your plot more legible. 
```

How do the stories that the two plots tell differ? What does your third plot tell you about the geo-political landscape of the issue you are studying? - OR - What does the third plot tell you about the temporal landscape of the issue you are studying?

```{r eval=FALSE}
Fill your response here. 
```

## The Importance of Place and Time

Time and place often matter a great deal in how we interpret data. To get us started in thinking about why, let's walk through a few examples:

### Case Study 1: Covid-19 Case Reporting by Country

Let's take a look at the number of Covid-19 cases reported each day by each country. To do so, we will be reimporting the cases data as a time series - that is, as a dataset that reports the number of cases per day. On import, every column represents a specific date and the case totals for that date are the values stored in that column. 
```{r}
cases_time_series <- read.csv("https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_time_series/time_series_covid19_confirmed_global.csv", stringsAsFactors = FALSE)

head(cases_time_series)
```

When dates are stored as column names and not as values in and of themselves, it can be very difficult to manipulate the data based on dates. Remember that column names are not data in and of themselves but a reference to a vector of values. The dates in this dataset are a reference to a vector of case numbers. Because the date values are not represented *in* the data, but only as a reference to case numbers, we can't filter observations to specific dates or to dates that happened before or after another date. The code below reshapes the data so that such filtering is possible.  Using **gather()**, for every province/country in the dataset, a new row will be created in the dataset for every date data was reported. The reshaped data will have two new columns: Case.Date (the date reported) and Cases (the number reported on that date). Basically, we will take wide data (many columns with fewer rows), and reshape it into long data (fewer columns with more rows). 

If you'd like to know more about how to use gather() to create tidy data, I highly recommend [this](https://r4ds.had.co.nz/tidy-data.html) chapter in R for Data Science.

You'll also not above that R automatically places an "X" character in front of numeric column names. Below we remove that X character and then we transform the values into a date-time format.   

```{r}
cases_time_series <- cases_time_series %>% 
  gather(key = "Case.Date", value = "Cases", -Province.State, -Country.Region, -Lat, -Long) %>%
  mutate(Case.Date = str_remove(Case.Date, pattern = "X")) %>%
  mutate(Case.Date = mdy(Case.Date))

head(cases_time_series)
```

Now let's plot the total number of cases reported each day, faceted by country. 

```{r fig.height=8, fig.width=10}
cases_time_series %>% 
  ggplot(aes(x = Case.Date, y = Cases)) + 
  stat_summary(geom = "col", fun.y = "sum") + 
  facet_wrap(~Country.Region) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust=1, size = 6), 
        axis.text.y = element_text(size = 6),
        strip.text = element_text(size = 6)) 
```

One observation that might stand out in this plot is just how few cases were reported in Russia through mid-March. As of March 24, 2020, Russia had reported fewer than 500 cases of Covid-19. For a country covering more than 6 million square miles, with a population of 145 million, and in such close proximity to China where the case counts are highest, these numbers are surprisingly low. Russian officials have claimed that measures they took - such as shutting down the Russian border with China and setting up isolation zones for quarantined patients - have helped to keep the virus under control. However, several news reports have been published casting skepticism on the numbers, suggesting that in Russia there is a widespread culture against producing information that may draw negative international attention. To interpret this plot then, we need to have an understanding of global *geopolitics*. The numbers that we see reported in some parts of the world will vary from numbers reported in other parts of the world, not because the values are actually different, but because there are different cultures of reporting in certain countries. 

Characterize the geo-politics in your own dataset. Why might it be important to consider the variable of place when interpreting your data?

```{r eval=FALSE}
Fill your response here in at least 100 words.
```


### Case Study 2: Calls to 311 during Hurricane Sandy

Now let's look at a time series of cases reported in the US. 

```{r}
cases_time_series %>% 
  filter(Country.Region == "US") %>%
  ggplot(aes(x = Case.Date, y = Cases)) + 
  stat_summary(geom = "col", fun.y = "sum") +
  theme_bw() 
```

This plot indicates that few cases were reported prior to mid-March. However, to responsibly interpret this plot, we need to pay close attention to how case totals are produced. The numbers of confirmed cases reported in this dataset are based on the number of Covid-19 tests that are reported positive. However, the extent of testing in the US has been variable since January due to a number of political, regulatory, and material roadblocks. Up through February, very few tests were being conducted in the US as the federal government downplayed the threat posed by the virus. A series of follow-up events continued to shift the testing landscape:

* February 5: The CDC [shipped](https://www.technologyreview.com/s/615323/why-the-cdc-botched-its-coronavirus-testing/) coronavirus test kits to state labs with contaminated reagents. These labs ended up having to send their samples to the CDC for testing. 
* February 29th: Up until this point, FDA regulations prevented labs from developing their own coronavirus test kits. On February, 29th, this rule was [lifted](https://www.fda.gov/news-events/press-announcements/coronavirus-covid-19-update-fda-issues-new-policy-help-expedite-availability-diagnostics) allowing high-complexity labs to develop and run tests under what is called an Emergency Use Authorization. 
* March 12th: Up until this point, in order for a lab to begin testing patients, they needed to be authorized by the FDA to do so. On March 12, the FDA [granted](https://www.fda.gov/news-events/press-announcements/coronavirus-covid-19-update-fda-gives-flexibility-new-york-state-department-health-fda-issues) more flexibility to states to authorize this testing.
* While these regulatory changes quickened the pace at which labs could test patients, at this point, a new issue was emerging. Labs began reporting [critical shortages](https://www.newyorker.com/news/news-desk/why-widespread-coronavirus-testing-isnt-coming-anytime-soon) of testing supplies and reagents for conducting tests. 

With every change in the testing landscape, we can expect that the number of cases reported will also change. To interpret this plot, we need to have an understanding of *chrono-politics*, or the politics of time. Importantly, these regulatory timelines are playing out differently in different countries. There is much to consider at the intersection of geo-politics and chrono-politics. 

Characterize the chrono-politics in your own dataset. Why might it be important to consider the variable of time when interpreting your data?

```{r eval=FALSE}
Fill your response here in at least 100 words.
```

## Confounding Variables

### Population

### Semantic Changes

Even categories that have institutionally standardized are constantly changing as a result of ____. 

## Continue your shiny app.

With this in mind, we are going to add the capacity for users to specify specific geographies and timeframes when viewing the data in our app. While I believe all of you have a geography represented in your data, some of you do not have date and time represented in your data. If this is the case, you may remove the commented data-time inputs from the code below. 

At this point, we will begin working in the ui code block and creating more crosstalk between the ui and the server. Users will input information into the front end of the app, and that input will be communicated to the server. More specifically, users will select a geography and a data/timeframe, and the server will filter the dataset according to the selected features and recreate the values/plots on the filtered data. 

Be sure to follow all commented instructions below to add inputs to your Shiny app. 

```{r}
geo_input_choices <- hospitals %>% select(STATE) %>% distinct() %>% arrange(STATE)
date_input_start <- hospitals %>% summarize(date = min(SOURCEDATE))
date_input_end <- hospitals %>% summarize(date = max(SOURCEDATE))

ui <- dashboardPage(
  
  dashboardHeader(title = "TITLE HERE"),
  
  dashboardSidebar(
      selectInput(inputId = "geo_val", label = "Select an geography:", choices = geo_input_choices, selected = geo_input_choices[1]),
      dateRangeInput(inputId = "date_val", label = "Select a date range:", start = date_input_start$date, end = date_input_end$date)
  ),
  
  dashboardBody(
      infoBoxOutput("value1", width = 4),
      infoBoxOutput("value2", width = 4),
      infoBoxOutput("value3", width = 4),
   
      box(plotOutput("plot1")),
      box(plotOutput("plot2")),
      box(plotOutput("plot3")),
      box(plotOutput("plot4"))

  )
)
  

```

In each of your functions below, you are going to add a filter statement, filtering to the user input. 

```{r}
server <- function(input, output) {
  
  output$value1 <- renderInfoBox({
    quant_insight1 <- 0
    #Replace '0' above with the code for one of the values you calculated above. Replace 'FILL DESCRIPTION HERE' with a brief description of this number.  
    infoBox(quant_insight1,'FILL DESCRIPTION HERE', icon = icon("stats", lib='glyphicon'), color = "purple")
  })
  
  output$value2 <- renderInfoBox({
    quant_insight2 <- 0
    #Replace '0' above with the code for one of the values you calculated above. Replace 'FILL DESCRIPTION HERE' with a brief description of this number.  
    infoBox(quant_insight2,'FILL DESCRIPTION HERE', icon = icon("stats", lib='glyphicon'), color = "purple")
  })
  
  output$value3 <- renderInfoBox({
    quant_insight3 <- 0
    #Replace '0' above with the code for one of the values you calculated above. Replace 'FILL DESCRIPTION HERE' with a brief description of this number.  
    infoBox(quant_insight3,'FILL DESCRIPTION HERE', icon = icon("stats", lib='glyphicon'), color = "purple")
  })
  
  
  output$plot1 <- renderPlot({
    hospitals %>% 
      filter(
        STATE == input$geo_val & 
        SOURCEDATE > input$date_val[1] &
        SOURCEDATE < input$date_val[2]
        ) %>%
      ggplot(aes(x = TYPE)) + geom_bar()
    #Replace plot above with your own plot. 
    
  })
  
  output$plot2 <- renderPlot({
    hospitals %>% 
      filter(
        STATE == input$geo_val & 
        SOURCEDATE > input$date_val[1] &
        SOURCEDATE < input$date_val[2]
        ) %>%
      ggplot(aes(x = TYPE)) + geom_bar()
    #Replace plot above with your own plot. 
  })
  
  output$plot3 <- renderPlot({
    hospitals %>% 
      filter(
        STATE == input$geo_val & 
        SOURCEDATE > input$date_val[1] &
        SOURCEDATE < input$date_val[2]
        ) %>%
      ggplot(aes(x = TYPE)) + geom_bar()
    #Replace plot above with your own plot. 
    
  })
  
  output$plot4 <- renderPlot({
    hospitals %>% 
      filter(
        STATE == input$geo_val & 
        SOURCEDATE > input$date_val[1] &
        SOURCEDATE < input$date_val[2]
        ) %>%
      ggplot(aes(x = TYPE)) + geom_bar()
    #Replace plot above with your own plot. 
  })
  
}
```


```{r}
shinyApp(ui, server)
```


## Other Case Studies to Consider (I will continue to grow this list)

### Case Study: Calls to 311 during Hurricane Sandy

311 is basically a customer service number for cities - a number for residents and visitors to report non-emergency issues, such as potholes and graffiti to city officials. In most cities, every call to 311 gets aggregated in a database, and increasingly, city officials are performing data analysis on the calls to figure out where certain issues in the city are concentrated. If they receive a number of calls about missed garbage pick-ups in a certain community, they may divert attention and resources there for improved sanitation. Often this data is publicly accessible for communities to analyze. 

```{r}
nyc311_zip <- unzip("https://github.com/lindsaypoirier/STS-115/blob/master/datasets/311_before_2015.csv.zip?raw=true")
nyc311 <- read.csv(nyc311_zip, stringsAsFactors = FALSE) 
nyc311$Created.Date<-mdy_hms(nyc311$Created.Date)
```

When Hurricane Sandy hit NYC in 2012, the City leveraged data about calls New Yorkers had made to 311 to track where a number of different issues were occurring. Visualizing data about 311 calls in the three months following the disaster indeed showed a spike in complaints about issues like damaged trees and lack of heat in apartment buildings throughout the city. Leveraging this data, the city was able to position the devastation of the disaster as episodic - a result of natural forces beyond their control.

```{r}
nyc311 %>% 
  filter(year(Created.Date) == 2012 & month(Created.Date) %in% c(7:11)) %>%
  ggplot(aes(x = as.Date(Created.Date), group = 1)) +
  geom_vline(xintercept=as.Date(c("2012-10-29")),linetype=4, colour="black") +
  geom_line(stat="count") + 
  facet_wrap(~Complaint.Type) + 
  labs(x="Month", y="Count") +
  scale_x_date() +
  theme_bw() +
  annotate(geom = "label", x = as.Date("2012-10-29"), y = 4000, label = "Hurricane Sandy", angle = 90)
```

However, social researchers have argued that it is not so simple to delimit the temporal boundaries of a disaster. While a natural event may happen on a particular day or span of days, the structural conditions of the communities they impact have much longer timespans. Natural events occurring in delimited periods of time often exacerbate existing social issues like poverty, lack of affordable housing, and unequal access to healthcare. 

Let's zoom out on the 311 data to look at these issues over the course of years versus these three months.  Complaints to 311 about damaged trees do spike following most major natural events. However, complaints about lack of heat in apartments spike every year in October ...because in New York, that's when it gets cold. By only look at the data in months immediately after the disaster, the city could obscure the big picture - that poor New Yorkers face apartment negligence every year. The temporal context in which we analyze data matters a great deal for how we interpret it. 

```{r fig.height=3, fig.width=10}
nyc311 %>% 
  ggplot(aes(x=as.Date(Created.Date), col=as.factor(year(Created.Date)), group = year(Created.Date))) +
  geom_vline(xintercept=as.Date(c("2010-03-12","2010-09-16","2011-08-28","2011-10-29","2012-10-29")),linetype=4, colour="black") +
  geom_line(stat = "count") + 
  facet_wrap(~Complaint.Type) +
  labs(x="Month", col="Year") +
  scale_x_date(breaks = "3 months", labels=date_format("%b-%y")) +
  theme_bw() +
  annotate(geom = "label", x = as.Date("2010-03-12"), y = 4000, label = "nor'easter", angle = 90) +
  annotate(geom = "label", x = as.Date("2010-09-16"), y = 4000, label = "tornadoes", angle = 90) +
  annotate(geom = "label", x = as.Date("2011-08-28"), y = 4000, label = "Hurricane Irene", angle = 90) +
  annotate(geom = "label", x = as.Date("2011-10-29"), y = 4500, label = "Halloween nor'easter", angle = 90) +
  annotate(geom = "label", x = as.Date("2012-10-29"), y = 4000, label = "Hurricane Sandy", angle = 90)
  #nor'easter, tornadoes, Irene, Halloween nor'easter, Sandy
```

> Liboiron, Max. 2015. “Disaster Data, Data Activism: Grassroots Responses to Representing Superstorm Sandy.” In Extreme Weather and Global Media, edited by Julia Leyda and Diane Negra. Taylor & Francis Group. https://doi.org/10.4324/9781315756486-7.


```{r}
hospitals %>% 
      filter(between(VAL_DATE, as.Date("2012-01-01"), as.Date("2019-01-01")))

hospitals %>% 
      filter(between(BEDS, 3, 5))
```

